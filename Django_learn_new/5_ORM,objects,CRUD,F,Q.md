# ORM CRUD操作（objects管理器对象）

前面完成了 MTV 模式（Model：模型，Template：模板，View：视图）的学习，接下来重点学习 Django 的 ORM（Object Relational Mapping，对象关系映射）

![](resources/2024-01-17-22-31-40.png)

关键是 **objects管理器对象**
![](resources/2024-01-17-22-33-13.png)

## 创建数据（Create）

### 方式1

执行 `objects.create()` 方法创建数据
```py
MyModel.objects.create(属性1=值1, 属性2=值2, ...)
```
成功：返回创建好的实体对象
失败：抛出异常

### 方式2

创建 MyModel 实体对象，然后调用 `save()` 方法进行保存
```py
obj=MyModel(属性1=值1, 属性2=值2, ...)
obj.属性3=值3
obj.save()
```

## 查询数据（Read）

![](resources/2024-01-17-23-26-28.png)

### all() 方法

用法：`MyModel.objects.all()`
作用：查询 MyModel 实体中的**所有的数据**
等同于：`select * from table`
返回值：**QuerySet容器对象**，内部存放 **MyModel实例**

### values('列1', '列2', ...) 方法

用法：`MyModel.objects.values('列1', '列2', ...)`
作用：查询**部分列的数据**
等同于：`select 列1, 列2 from table`
返回值：**QuerySet容器对象**，内部存放 **字典**，每个字典代表一条数据，格式为 `{'列1':值1, '列2':值2}`

### values_list('列1', '列2', ...) 方法

用法：`MyModel.objects.values_list('列1', '列2', ...)`
作用：返回**元组形式**的查询结果
等同于：`select 列1, 列2 from table`
返回值：**QuerySet容器对象**，内部存放 **元组**，会将查询出来的数据封装到元组中，再封装到查询集合QuerySet中

### order_by('-列', '列', ...) 方法

用法：`MyModel.objects.order_by('-列', '列', ...)`
作用：与 all() 方法不同，它会用SQL语句的 **ORDER BY 子句** 对查询结果进行根据某个字段选择性地进行**排序**
说明：默认是按照**升序**排序，降序排序则需要在列前加`-`表示
返回值：**QuerySet容器对象**，内部存放 **MyModel实例**

### filter(条件) 方法（条件查询）

用法：`MyModel.objects.filter(条件)`
作用：返回**包含此条件**的全部的数据集
说明：当多个属性在一起时是 **与** 的关系
返回值：**QuerySet容器对象**，内部存放 **MyModel实例**

#### 条件

条件可以简单地写成 `(属性1=值1, 属性2=值2, ...)`
注意：
1. 上面参数里的作为 **列名** 时（用于**筛选列**），**需要用引号**
2. 而参数里的作为 **属性名** 时（用于**筛选行**），**不需要用引号**

但是，怎么做**非等值**的过滤查询？

做更**灵活**的条件查询时需要使用**查询谓词**

##### 查询谓词

每个查询谓词是一个独立的查询功能
查询谓词**拼接到属性名的后面**，再后面跟**等号**

常见的查询谓词有：
`__exact`:等值匹配
`__contains`:包含指定的值
`__startswith`：以xxx开始
`__endswith`：以xxx结尾
`__gt`：大于指定值
`__gte`：大于等于
`__lt`：小于
`__lte`：小于等于
`__in`：查找数据是否在指定的集合内
`__range`：查找数据是否在指定的区间范围内

示例如下
![](resources/2024-01-21-00-03-31.png)

### exclude(条件) 方法（条件查询）

用法：`MyModel.objects.exclude(条件)`
作用：返回**不包含此条件**的全部的数据集
说明：当多个属性在一起时是 **与** 的关系
返回值：**QuerySet容器对象**，内部存放 **MyModel实例**

### get(条件) 方法（条件查询）

用法：`MyModel.objects.get(条件)`
作用：返回满足条件的**唯一一条数据**
说明：该方法只能返回一条数据，如果查询到多条数据或者没查询到数据则**抛出异常**，所以要用 **try-catch** 语句来**处理异常**
返回值：**MyModel实例**

### 链式查询

**只要返回结果是 QuerySet容器对象，其后可继续链式使用这些查询方法**

示例如下
![](resources/2024-01-21-00-13-41.png)

### 输出后台执行的SQL语句

通过打印 `QuerySet.query` 可以查看到后台执行的SQL语句

示例如下
![](resources/2024-01-21-00-19-05.png)

## 更新数据（Update）

### 先get()再save()（更新单个数据）

查：通过 `get()` 方法得到要修改的对象
改：通过 `对象.属性` 的方式修改数据
保存：通过对象的 `save()` 方法保存数据

### update(属性1=值1, 属性2=值2, ...)（批量更新数据）

查：通过查询方法得到要修改的 **QuerySet容器对象**
改：直接调用 **QuerySet容器对象** 的 `update(属性1=值1, 属性2=值2, ...)` 即可实现批量修改，返回值为 **影响行数**

示例如下
![](resources/2024-01-21-00-25-51.png)

## 删除数据（Delete）

### 删除单个数据

查：通过 `get()` 方法得到要修改的对象
删：通过对象的 `delete()` 方法删除数据

### 批量删除数据

查：通过查询方法得到要删除的 **QuerySet容器对象**
删：调用 **QuerySet容器对象** 的 `delete()` 方法实现删除

### 伪删除

通常不会轻易在业务里把数据真的删除，取而代之的是做伪删除，即在表中增加一个布尔型字段`is_active`，默认是`True`，执行删除时，将欲删除数据的`is_active`字段设置为`False`即可
注意：使用伪删除时，确保显示数据的地方，均增加了`is_active=True`的过滤查询

# ORM 中的 F对象 和 Q对象

## F对象

### 简介

一个F对象代表数据库中 **某条记录的字段的信息**

### 作用

- 通常是对数据库中的字段值在不获取的情况系进行操作
- 用于字段之间的比较

### 语法

```py
from django.db.models import F
F("列名")
```

### 示例1：对数据库中的字段值在不获取的情况系进行操作

需求：所有 Article 的 support 值增加1



看csdn网页





如果不使用F对象
```py

```

使用F对象则变得非常简单，而且不需要将所有数据都查询出来遍历处理
```py

```

用 .query 看看具体的sql语句
相当于 += 




如果请求很多且很快，

P23视频 13min

资源竞争
并发

### 示例2：用于字段之间的比较


P23 20min


## Q对象

### 简介

`filter()` 等方法中的多个条件参数都是一起进行 **与**（AND）的，如果想要实现条件的 **或**（OR）、**非**（NOT）的逻辑，会很复杂，Q对象就是为了将这些条件用逻辑或、逻辑与、逻辑非组合起来
一个Q对象代表一个 **查询条件**

使用符号&或者|将多个Q()对象组合起来传递给filter()，exclude()，get()等函数。当多个Q()对象组合起来时，Django会自动生成一个新的Q()

当在获取查询结果集，使用复杂的逻辑或、逻辑与、逻辑非等操作时可以借助Q对象进行操作

### 作用

在条件中用来实现 **and**（`&`）、**or**（`|`）、**not**（`~`）的逻辑关系

### 语法

```py
from django.db.models import Q
Q(条件)
Q(条件1) & Q(条件2)
Q(条件1) | Q(条件2)
~Q(条件1)
```

### 示例

如果不使用Q对象
```py
见
https://blog.csdn.net/weixin_30336061/article/details/96189001
```

使用Q对象则变得非常简单，而且不需要方法的链式调用
```py

```


# ORM 中的 聚合查询

聚合查询函数是**对一组值执行计算，并返回单个值**
如查询文章的的平均点赞数，查询文章的个数等，都要使用到聚合查询

聚合查询分为：
- 整表聚合
- 分组聚合

## 整表聚合（aggregate）

整表聚合就是**不带分组的聚合查询**，即将全部数据进行集中统计查询

聚合查询需要导入聚合函数
```py
from django.db.models import *
常见的聚合函数有Sum，Avg，Count，Max，Min
```

### 语法


聚合函数aggregate()是QuerySet的一个终止子句，生成的一个汇总值，相当于count()。

使用aggregate()后，数据类型就变为字典，不能再使用QuerySet数据类型的一些API了。

返回的字典中：键的名称默认是（属性名称加上__聚合函数名），值是计算出来的聚合值

要自定义返回字典的键的名称，可以起别名：


```py
MyModel.objects.aggregate(别名=聚合函数（‘列’）)

```

返回结果：结果变量名和值 组成的**字典**，即 `{'结果变量名': 值}`








## 分组聚合

分组聚合就是指通过计算查询结果中的每一个对象所关联的对象集合，从而得出总计值，即为查询集的每一项生成聚合

### 语法

QuerySet.annotate(结果变量名=聚合函数（‘列’）)
返回值为QuerySet


P24 11min

having




# ORM 中使用 原生数据库操作

## 查询

语法1：MyModel.objects.raw(sql语句)，不安全，存在SQL注入风险
语法2：MyModel.objects.raw(sql语句，条件参数),此种安全，django默认处理掉SQL注入风险
返回值：**RawQuerySet集合对象**，只支持基础操作，比如循环

P24

SQL注入

## 




